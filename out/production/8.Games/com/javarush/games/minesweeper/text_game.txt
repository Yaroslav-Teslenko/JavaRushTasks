15
Как известно, настоящий сапер ошибается только один раз. Но, к счастью, у нас есть право на ошибку, и даже не одну.

Давай реализуем механизм рестарта игры. Для этого создадим метод restart(), в котором будем запускать игру,
сбрасывать в исходное состояние количество закрытых ячеек, мин на поле и очков. Не забудь об обновлении счета на
игровом поле и о вызове метода, который отвечает за создание игры.

Также в методе restart() нужно очистить игровое поле от флагов, мин, чисел и пр. Рестартовать игру будем по нажатию левой кнопки мыши.


Requirements:
1. В классе MinesweeperGame должен существовать private void метод restart().
2. Присваивание значения false полю isGameStopped должно происходить в методе restart().
3. Присваивание значения полю isGameStopped не должно происходить в методе createGame().
4. В методе restart() должны возвращаться исходные значения полей countClosedTiles, score и countMinesOnField.
5. Метод restart() должен вызывать метод setScore(int).
6. Метод restart() должен вызывать метод createGame() после установки исходных значений полей countClosedTiles, score и countMinesOnField.
7. В методе createGame() игровое поле должно очищаться от всех надписей (флагов, мин, чисел).
Используй метод setCellValue(int, int, String). В качестве последнего параметра передай пустую строку.
8. Метод onMouseLeftClick(int, int) должен вызывать метод restart() и ничего не делать, если игра остановлена.

14
Согласись, без счета играть не очень интересно. Давай добавим этот функционал в нашу игру. Нам понадобится
переменная для учета очков. При открытии ячейки без мины счет увеличивается на 5 очков.

Чтобы счет отображался на игровом поле, нам нужно воспользоваться специальным методом setScore() класса Game,
в который передадим общее количество очков. Обрати внимание, что вызывать этот метод нужно после увеличения счета —
иначе будет показан неправильный результат.

Запусти игру и попробуй набрать максимальное количество очков.


Requirements:
1. В классе MinesweeperGame должно существовать приватное поле score типа int.
2. В методе openTile(int, int) значение поля score должно увеличиваться на 5, если элемент матрицы gameField
отмечается флагом isOpen и этот элемент не является миной.
3. В методе openTile(int, int) должен вызываться метод setScore(int) с параметром score.

13
Игра считается выигранной, когда количество оставшихся закрытых ячеек равно количеству мин. Для подсчета
числа закрытых ячеек введем дополнительную переменную, значение которой изначально равно общему количеству
ячеек на игровом поле. Значение этой переменной будет уменьшаться по мере открытия ячеек.
Когда ее значение станет равно количеству мин, игра будет выиграна.

На данный момент, в нашей игре в случае выигрыша ничего не происходит, а должно бы. Пора это исправить.

Давай напишем метод win(), в котором будем останавливать игру и поздравлять победителя красивым сообщением.

Запусти игру и проверь, что при выигрыше отработал метод win().
Обрати внимание, что метод win() вызывается, если количество закрытых ячеек равно количеству мин на поле. При этом,
если последняя открытая ячейка оказалась миной, то метод не должен быть вызван.


Requirements:
1. В классе MinesweeperGame должно существовать приватное поле countClosedTiles типа int, инициализированное при объявлении значением SIDE * SIDE.
2. В методе openTile(int, int) значение поля countClosedTiles должно уменьшаться на 1, если элемент матрицы gameField отмечается флагом isOpen.
3. В классе MinesweeperGame должен существовать приватный метод void win().
4. Метод win() должен устанавливать значение переменной isGameStopped в true.
5. Метод win() должен вызывать метод showMessageDialog(Color, String, Color, int).
6. Метод openTile(int, int) должен вызывать метод win(), если количество не открытых ячеек равно количеству мин на поле, и последняя открытая ячейка не является миной.

12
Ячейку можно открыть только раз. Если ячейка отмечена флагом, она не должна открываться.

Ну и, конечно же, ячейки не должны открываться после того, как игра была остановлена.
Давай учтем все эти моменты в методе openTile(int, int). Теперь нужно убедиться, что все работает корректно — запусти игру и проверь.


Requirements:
1. Метод openTile(int, int) не должен ничего делать, если элемент уже открыт.
2. Метод openTile(int, int) не должен ничего делать, если элемент отмечен флагом.
3. Метод openTile(int, int) не должен ничего делать, если игра остановлена (isGameStopped == true).

11

Практически в любой игре игрок либо выигрывает, либо проигрывает. Давай для начала реализуем проигрыш.

Для этого нам пригодится метод gameOver(), который будет останавливать игру и сообщать игроку о проигрыше.

Для вывода сообщения игроку в движке предусмотрен метод showMessageDialog().

Чтобы контролировать остановку игры, введем специальную переменную-флаг isGameStopped. При каких обстоятельствах
происходит проигрыш? Правильно: при открытии "заминированной" ячейки. Если такое событие наступило, нужно ячейку с
миной перекрасить в красный цвет (Color.RED) и вызвать метод gameOver().

Не забудь учесть остановку игры в методе markTile(int, int). Запусти игру и проверь, что все реализованное тобой работает.


Requirements:
1. В классе MinesweeperGame должно существовать приватное поле isGameStopped типа boolean.
2. В методе createGame() должно устанавливаться значение переменной isGameStopped в false.
3. В классе MinesweeperGame должен существовать приватный метод void gameOver().
4. Метод gameOver() должен устанавливать значение переменной isGameStopped в true.
5. Метод gameOver() должен вызывать метод showMessageDialog(Color, String, Color, int).
6. В методе openTile(int, int), если объект является миной, должна отрисовываться мина на
красном фоне (используй метод setCellValueEx(int, int, Color, String)) и вызываться метод gameOver().
7. Метод markTile(int, int) не должен ничего делать, если игра уже остановлена (isGameStopped == true).


10
Теперь давай займемся реализацией метода, который отвечает за маркировку ячейки флажком. Метод назовем markTile .

Он должен:

- отмечать ячейку на игровом поле флагом или снимать флаг;
- следить за количеством флагов;
- заниматься отрисовкой и стиранием флагов на игровом поле;
- менять цвет ячейки поля, если в ней устанавливается флаг и возвращать цвет обратно, если флаг снимается.

Поставить или снять флаг в игре можно с помощью клика правой кнопки мыши. Поэтому в классе
MinesweeperGame нужно переопределить метод onMouseRightClick(int, int) класса
Game и в нем вызвать метод markTile(int x, int y).

Проверь, что все работает — запусти игру.


Requirements:
1. В классе MinesweeperGame должен существовать приватный метод void markTile(int, int).
2. Метод markTile(int x, int y) не должен ничего делать, если элемент уже открыт (isOpen == true).
3. Метод markTile(int, int) не должен ничего делать, если количество неиспользованных флагов countFlags равно нулю,
и текущий элемент — не флаг (isFlag = false).
4. Метод markTile(int, int) должен
устанавливать значение поля isFlag в true,
уменьшать количество неиспользованных флагов на единицу,
отрисовывать на поле знак FLAG, если текущий элемент —не флаг (используй метод setCellValue(int, int, String)) и
менять фон ячейки на поле, используя метод setCellColor(int, int, Color). Например, в Color.YELLOW.

5. Метод markTile(int, int) должен
устанавливать значение поля isFlag в false,
увеличивать количество неиспользованных флагов на единицу,
отрисовывать на поле пустую ячейку, если текущий элемент — флаг (используй метод setCellValue(int, int, String))
 возвращать исходный цвет ячейки (используй метод setCellColor(int, int, Color)).

6. В классе MinesweeperGame должен быть переопределен метод onMouseRightClick(int, int) родительского класса Game.
7. Метод onMouseRightClick(int, int) должен вызывать метод markTile(int, int).

9

Игра сапер (9/16)
Согласно правилам игры, при открытии ячейки, количество "заминированных" соседей которой равно нулю, открывается
некоторая "не заминированная" область до ячеек с "заминированными" соседями. Давай это реализуем... Предлагаю
использовать рекурсию. Ее применяют тогда, когда алгоритм решения задачи совпадает с алгоритмом решения подзадачи
(части). У нас как раз такой случай.

При открытии ячейки с нулевым количеством "заминированных" соседей нам нужно сделать полный перебор всех закрытых
соседних ячеек, вызвать у них метод openTile(int, int) и повторить процесс.
Также в методе openTile(int, int) реализуем показ в ячейке количества "заминированных" соседей.
Запусти игру, чтобы проверить корректность реализации.
Подсказка: если получил java.lang.StackOverflowError, значит ты поздно устанавливаешь флаг, что ячейка уже открыта.


Requirements:
1. В методе openTile(int, int), если элемент не является миной и количество соседей-мин равно нулю, для каждого не
открытого соседа должен рекурсивно вызываться метод openTile(int, int).
2. Метод openTile(int, int) должен вызывать метод getNeighbors(GameObject), если элемент не является миной и
количество соседей-мин равно нулю.
3. В методе openTile(int, int), если элемент не является миной и количество соседей мин не равняется нулю, на игровое
поле должно выводиться количество заминированных соседей. Используй метод setCellNumber(int, int, int).
4. Метод openTile(int, int) не должен ничего выводить, если элемент не является миной и количество соседей мин равно
нулю. Используй пустую строку.

8
Игра сапер (8/16)
Согласно правилам игры, в помощь игроку даются флаги. Они нужны, чтобы помечать потенциально "заминированные" ячейки.
Поэтому количество флагов countFlags должно равняться количеству мин countMinesOnField.

Флаг нужно как-то показывать на игровом поле. Для этого создадим переменную-константу, которая будет хранить его символ.
У каждой ячейки модели должно быть состояние isFlag, которое покажет нам, помечена ли ячейка флагом или нет.
Requirements:
1. В классе MinesweeperGame должно существовать приватное статическое final поле String FLAG, инициализированное
при объявлении. Например, использовать можно UTF-16 символ флага "\uD83D\uDEA9".
2. В классе MinesweeperGame должно существовать приватное поле countFlags типа int, в котором будет храниться
количество неиспользованных флагов.
3. В методе createGame() должно устанавливаться значение поля countFlags равное countMinesOnField.
4. В классе GameObject должно существовать публичное поле isFlag типа boolean.

7
Игра сапер (7/16)
На данном этапе мы займемся открытием ячеек. Давай создадим метод, отвечающий за это, и переменную, которая будет
хранить состояние ячейки (открыта или нет).

При открытии ячейки метод будет:
- рисовать в ячейке мину, если там мина;
- отображать количество мин-соседей, если в ячейке нет мины;
- отмечать ячейку модели открытой;
- менять цвет ячейки.
Символ мины для удобства предлагаем вынести в отдельную переменную-константу. Когда ячейка должна открываться?
Правильно, при клике по ней левой кнопкой мыши. Для обработки такого нажатия существует специальный метод движка
 — onMouseLeftClick(int, int).Давай переопределим его в нашем классе. Он будет вызывать метод открытия ячейки.
Ну и, конечно же, запусти программу и насладись результатом работы.


Requirements:
1. В классе MinesweeperGame должно существовать приватное статическое final поле String MINE, инициализированное
при объявлении. Например, использовать можно UTF-16 символ мины "\uD83D\uDCA3".
2. В классе MinesweeperGame должен существовать приватный метод void openTile(int x, int y).
3. Метод openTile(int, int) должен отрисовывать MINE, если gameObject по текущим координатам является миной.
 Используй метод setCellValue(int, int, String).
4. Метод openTile(int, int) должен отрисовывать количество соседей-мин, если gameObject по текущим координатам не
является миной. Используй метод setCellNumber(int, int, int).
5. В классе GameObject должно существовать публичное поле isOpen типа boolean.
6. В методе openTile(int, int) элементу матрицы gameField должно устанавливаться значение поля isOpen, равное true,
и отрисовываться фон ячейки с помощью метода setCellColor(int, int, Color). Например, в Color.GREEN.
7. В классе MinesweeperGame должен быть переопределен метод onMouseLeftClick(int, int) родительского класса Game.
8. В методе onMouseLeftClick(int, int) должен быть вызван метод openTile(int, int).


6
Теперь давай займемся подсчетом мин в соседних ячейках. Для этого каждой ячейке матрицы добавим параметр (поле класса),
который отвечает за количество "заминированных" соседей.
Для начала найдем всех соседей, а потом посчитаем, сколько из них "заминированы". Для получения списка соседей у тебя
 появился метод getNeighbors, который принимает один параметр типа GameObject (ячейку).
И, наконец, в отдельном методе мы посчитаем количество "заминированных" соседей для каждой ячейки gameField и внесем
это значение в соответствующее поле ячейки матрицы
Хотя визуально твоя работа не видна (ты же запустил программу, чтобы посмотреть что получилось?), она очень важна
для будущих шагов..
Requirements:
1. В классе GameObject должно существовать публичное поле countMineNeighbors типа int.
2. В классе MinesweeperGame должен существовать приватный void метод countMineNeighbors().
3. Метод countMineNeighbors() должен для каждой ячейки "не мины" из матрицы gameField подсчитать количество соседних
ячеек "мин" и установить это значение в поле countMineNeighbors.
4. В методе countMineNeighbors() должен использоваться метод getNeighbors(GameObject gameObject).
5. В методе createGame() после создания всех элементов матрицы gameField должен быть вызван метод countMineNeighbors().
5
Игра "Сапер" не зря так называется. Игроку нужно будет иметь дело с минами, хотя лучше с ними дела не иметь :)
Давай введем в игру эти самые мины. Для этого в класс GameObject внесем изменения, которые учитывают, что
ячейка может быть миной — это флаг isMine.
Новый конструктор создавать не нужно: достаточно отредактировать существующий.
Кроме того, при создании ячеек матрицы добавь генерацию мин с вероятностью 10%. Самый простой способ это сделать —
 использовать метод getRandomNumber(int n) класса Game, который возвращает случайное число от 0 до n-1 включительно.
  Следовательно, вероятность генерации определенного числа равна 1/n.
Также не забудь посчитать количество сгенерированных мин в классе MinesweeperGame.
Если все сделал, запусти программу и проверь, что ничего не поломалось :)

Requirements:
1. В классе GameObject должно существовать публичное поле isMine типа boolean.
2. В классе GameObject должен существовать один конструктор с тремя параметрами типа int, int, boolean, который
 устанавливает соответствующие значения полям x, y и isMine в указанном порядке.
3. В классе MinesweeperGame должно существовать приватное поле countMinesOnField типа int.
4. В методе createGame() при создании ячеек должно случайным образом задаваться, будет ли эта ячейка с миной. Используй
метод getRandomNumber(int) класса Game с параметром 10.
метод getRandomNumber(int) класса Game с параметром 10.
5. После выполнения метода createGame() полю countMinesOnField должно быть присвоено значение количества мин на поле.


4
Игра сапер (4/16)
Состояние ячеек игрового поля нужно где-то хранить. Для этой задачи создадим матрицу (двумерный массив) с размерами
игрового поля. Чтобы увидеть состояние игры на экране, нам нужно передать в отображение данные из матрицы. Отображение
отвечает только за визуальную информацию и смысловой нагрузки не несет.
В этом нам поможет метод setCellColor(int, int, Color) класса Game, параметры которого — координаты и цвет ячейки.
Давай вызовем его и передадим координаты каждой ячейки матрицы и любой цвет (например, Color.ORANGE).
Предлагаем вынести отрисовку матрицы на отображении в отдельный метод createGame(), который потом вызовем из метода
initialize(). Запусти программу и посмотри, что получилось.
Подсказка: чтобы вызвать метод setCellColor(int, int, Color) для каждой ячейки матрицы, воспользуйся циклами.

Requirements:
1. В классе MinesweeperGame должна существовать приватная матрица (двумерный массив) gameField с
типом GameObject[][] и размером SIDEхSIDE.
2. В классе MinesweeperGame должен существовать приватный метод void createGame().
3. В методе createGame() нужно заполнить все ячейки массива gameField новыми объектами типа GameObject с
соответствующими координатами x и y.
4. В методе createGame() для каждой ячейки массива gameField нужно вызвать метод setCellColor(int, int, Color) с
параметрами: координаты x и y, а также любой цвет (например, Color.ORANGE).
5. В методе initialize() должен быть вызван метод createGame().